#!/bin/bash
# Quality Budgets Check Script
# Technology-agnostic budget validation
# Report-only: exits 0 always, provides actionable feedback

set -euo pipefail

# Colors for output (fallback to no colors on Windows)
RED=""
GREEN=""
YELLOW=""
BLUE=""
NC=""
if [[ -t 1 ]] && [[ "$(uname -s)" != "MINGW"* ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
fi

# Configuration
BUDGETS_FILE="quality-budgets.json"
GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:-}"

# Results tracking
results=()
warnings=()
recommendations=()

# Helper functions
log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
log_warn() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
log_error() { echo -e "${RED}‚ùå $1${NC}"; }
log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }

add_result() { results+=("$1"); }
add_warning() { warnings+=("$1"); }
add_recommendation() { recommendations+=("$1"); }

# Load budgets from JSON
load_budgets() {
    if ! command -v jq &> /dev/null; then
        log_warn "jq not available - using basic budget checks"
        echo '{"budgets":{"performance":{"buildTimeMs":300000,"testTimeMs":60000,"bundleSizeKb":100},"quality":{"testCoveragePercent":80}}}'
        return
    fi

    if [[ -f "$BUDGETS_FILE" ]]; then
        cat "$BUDGETS_FILE"
    else
        log_warn "Budget file $BUDGETS_FILE not found - using defaults"
        echo '{"budgets":{"performance":{"buildTimeMs":300000,"testTimeMs":60000,"bundleSizeKb":100},"quality":{"testCoveragePercent":80}}}'
    fi
}

# Check build time budget
check_build_time() {
    local budgets="$1"
    local build_time_ms

    # Try to detect build time from common sources
    if [[ -n "${BUILD_TIME_MS:-}" ]]; then
        build_time_ms="$BUILD_TIME_MS"
    elif [[ -f "build.log" ]] && command -v grep &> /dev/null; then
        # Try to extract from build log (basic pattern)
        build_time_ms=$(grep -oE "[0-9]+(\.[0-9]+)?ms" build.log | tail -1 | sed 's/ms//' 2>/dev/null || echo "")
    fi

    if [[ -z "$build_time_ms" ]]; then
        add_warning "Build time not measured - consider adding timing to your build process"
        return
    fi

    local budget_ms
    budget_ms=$(echo "$budgets" | jq -r '.performance.buildTimeMs // 300000' 2>/dev/null || echo "300000")

    if (( $(echo "$build_time_ms > $budget_ms" | bc -l 2>/dev/null || echo "0") )); then
        add_result "‚ùå Build time: ${build_time_ms}ms (budget: ${budget_ms}ms)"
        add_recommendation "Optimize build performance or increase buildTimeMs budget"
    else
        add_result "‚úÖ Build time: ${build_time_ms}ms (budget: ${budget_ms}ms)"
    fi
}

# Check test time budget
check_test_time() {
    local budgets="$1"
    local test_time_ms

    # Try to detect test time from environment or logs
    if [[ -n "${TEST_TIME_MS:-}" ]]; then
        test_time_ms="$TEST_TIME_MS"
    fi

    if [[ -z "$test_time_ms" ]]; then
        add_warning "Test time not measured - consider adding timing to your test process"
        return
    fi

    local budget_ms
    budget_ms=$(echo "$budgets" | jq -r '.performance.testTimeMs // 60000' 2>/dev/null || echo "60000")

    if (( $(echo "$test_time_ms > $budget_ms" | bc -l 2>/dev/null || echo "0") )); then
        add_result "‚ùå Test time: ${test_time_ms}ms (budget: ${budget_ms}ms)"
        add_recommendation "Optimize test performance or increase testTimeMs budget"
    else
        add_result "‚úÖ Test time: ${test_time_ms}ms (budget: ${budget_ms}ms)"
    fi
}

# Check bundle size budget
check_bundle_size() {
    local budgets="$1"
    local bundle_size_kb

    # Try to detect bundle size from common build outputs
    if [[ -n "${BUNDLE_SIZE_KB:-}" ]]; then
        bundle_size_kb="$BUNDLE_SIZE_KB"
    elif [[ -d "dist" ]] || [[ -d "build" ]]; then
        # Basic size calculation (very rough)
        local build_dir="dist"
        [[ -d "build" ]] && build_dir="build"

        if command -v du &> /dev/null; then
            bundle_size_kb=$(du -sk "$build_dir" 2>/dev/null | cut -f1 | head -1 || echo "")
        fi
    fi

    if [[ -z "$bundle_size_kb" ]]; then
        add_warning "Bundle size not measured - consider adding size tracking to your build process"
        return
    fi

    local budget_kb
    budget_kb=$(echo "$budgets" | jq -r '.performance.bundleSizeKb // 100' 2>/dev/null || echo "100")

    if (( bundle_size_kb > budget_kb )); then
        add_result "‚ùå Bundle size: ${bundle_size_kb}KB (budget: ${budget_kb}KB)"
        add_recommendation "Optimize bundle size through code splitting, tree shaking, or compression"
    else
        add_result "‚úÖ Bundle size: ${bundle_size_kb}KB (budget: ${budget_kb}KB)"
    fi
}

# Check test coverage
check_test_coverage() {
    local budgets="$1"
    local coverage_percent

    # Try to detect coverage from common sources
    if [[ -n "${TEST_COVERAGE_PERCENT:-}" ]]; then
        coverage_percent="$TEST_COVERAGE_PERCENT"
    elif [[ -f "coverage/coverage-summary.json" ]] && command -v jq &> /dev/null; then
        # Try to extract from Istanbul coverage report
        coverage_percent=$(jq -r '.total.lines.pct' coverage/coverage-summary.json 2>/dev/null || echo "")
    fi

    if [[ -z "$coverage_percent" ]]; then
        add_warning "Test coverage not measured - consider adding coverage reporting to your tests"
        return
    fi

    local budget_percent
    budget_percent=$(echo "$budgets" | jq -r '.quality.testCoveragePercent // 80' 2>/dev/null || echo "80")

    if (( $(echo "$coverage_percent < $budget_percent" | bc -l 2>/dev/null || echo "0") )); then
        add_result "‚ùå Test coverage: ${coverage_percent}% (budget: ${budget_percent}%)"
        add_recommendation "Increase test coverage by adding more unit tests"
    else
        add_result "‚úÖ Test coverage: ${coverage_percent}% (budget: ${budget_percent}%)"
    fi
}

# Main checks
main() {
    log_info "Running quality budget checks..."

    local budgets_json
    budgets_json=$(load_budgets)

    # Run individual checks
    check_build_time "$budgets_json"
    check_test_time "$budgets_json"
    check_bundle_size "$budgets_json"
    check_test_coverage "$budgets_json"

    # Generate report
    local total_results=${#results[@]}
    local total_warnings=${#warnings[@]}
    local total_recommendations=${#recommendations[@]}

    echo
    log_info "Quality Budget Check Results"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

    if [[ $total_results -gt 0 ]]; then
        echo "Budget Checks:"
        for result in "${results[@]}"; do
            echo "  $result"
        done
        echo
    fi

    if [[ $total_warnings -gt 0 ]]; then
        log_warn "Warnings:"
        for warning in "${warnings[@]}"; do
            echo "  ‚Ä¢ $warning"
        done
        echo
    fi

    if [[ $total_recommendations -gt 0 ]]; then
        log_info "Recommendations:"
        for recommendation in "${recommendations[@]}"; do
            echo "  ‚Ä¢ $recommendation"
        done
        echo
    fi

    # GitHub Actions summary
    if [[ -n "$GITHUB_STEP_SUMMARY" ]]; then
        {
            echo "## Quality Budget Check Results"
            echo
            if [[ $total_results -gt 0 ]]; then
                echo "### Budget Status"
                for result in "${results[@]}"; do
                    echo "- $result"
                done
                echo
            fi
            if [[ $total_warnings -gt 0 ]]; then
                echo "### Warnings"
                for warning in "${warnings[@]}"; do
                    echo "- ‚ö†Ô∏è $warning"
                done
                echo
            fi
            if [[ $total_recommendations -gt 0 ]]; then
                echo "### Recommendations"
                for recommendation in "${recommendations[@]}"; do
                    echo "- üí° $recommendation"
                done
                echo
            fi
        } >> "$GITHUB_STEP_SUMMARY"
    fi

    # Policy enforcement mode
    local policy_enforcement="${POLICY_ENFORCEMENT:-report-only}"
    local failed_checks
    failed_checks=$(echo "${results[@]}" | grep -c "‚ùå" || echo "0")

    if [[ "$policy_enforcement" == "enforced" ]] && [[ $failed_checks -gt 0 ]]; then
        log_error "Policy enforcement enabled: $failed_checks budget violation(s) - blocking"
        return 1
    elif [[ $failed_checks -gt 0 ]]; then
        log_warn "$failed_checks budget check(s) exceeded limits (report-only mode)"
    else
        log_success "All budget checks passed!"
    fi

    return 0
}

# Run main function
main "$@"
