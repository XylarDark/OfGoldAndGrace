# Cursor Rules: Of Gold And Grace Shopify Theme
# Curated from cursor.directory best practices
# Version: 2.0 - Enhanced Shopify Theme Guidelines

project_goals:
  - Minimal cost: Shopify Online Store 2.0 theme only; no headless stack or paid services.
  - WCAG AA accessibility compliance with keyboard navigation and screen reader support.
  - Core Web Vitals optimization: LCP < 2.5s, CLS < 0.1, FID < 100ms.
  - SEO-first: Structured data, semantic HTML, performance-optimized assets.
  - Developer experience: Automated testing, linting, CI/CD, and comprehensive documentation.

languages:
  - liquid: Shopify templating with Online Store 2.0 sections/snippets
  - javascript: ES2020+ vanilla JS, modular assets/, no frameworks
  - css: Theme tokens, utility-first, responsive design
  - json: Configuration, locales, and structured data

guardrails:
  - No server-side code: Shopify Liquid only; no Node.js, PHP, or external runtimes.
  - Secrets management: API keys in theme settings only; never commit credentials.
  - External services: Free tier only; document all app installs in PR descriptions.
  - Performance budget: Bundle size < 100KB JS/CSS; defer non-critical assets.
  - Browser support: Chrome, Safari, Firefox, Edge (last 2 versions).
  - localStorage usage: Handle quota exceeded errors; no sensitive data storage.

code_style:
  liquid:
    - Sections/snippets architecture: Reusable, configurable components.
    - Minimal logic: Prefer settings schema over inline conditionals.
    - Accessibility first: Alt text, ARIA labels, semantic HTML structure.
    - Performance: Lazy load images, optimize loops, cache expensive operations.
  javascript:
    - ES2020+ features: Async/await, optional chaining, nullish coalescing.
    - Modular architecture: One responsibility per file in assets/.
    - Performance: Defer/async scripts, IntersectionObserver for lazy loading.
    - Accessibility: Focus traps, keyboard navigation, ARIA live regions.
    - Error handling: Try/catch blocks, graceful degradation, user feedback.
    - No frameworks: Vanilla JS only; small utility functions.
  css:
    - Theme tokens: CSS custom properties for colors, spacing, typography.
    - Utility-first: Composible classes over monolithic components.
    - Responsive: Mobile-first with fluid typography and spacing.
    - Performance: Minimize specificity, avoid @import, optimize selectors.
    - Accessibility: Focus indicators, reduced motion, high contrast support.
    - No !important: Use specificity hierarchy instead.

files:
  - Core protection: layout/, config/, locales/ - never modify without review.
  - Theme configuration: config/settings_schema.json for all settings.
  - Component architecture: sections/ for pages, snippets/ for reusable parts.
  - Asset organization: assets/ for JS/CSS/images; __tests__/ for testing.
  - Documentation: README.md, .cursorrules, .github/ templates and guidelines.

patterns:
  - Quick View: data-quick-view="product-handle" on buttons.
  - Wishlist: data-wishlist-toggle with data-product-handle and data-product-title.
  - Lazy Images: data-src + class="lazy" + width/height/aspect-ratio attributes.
  - Modals: data-focus-trap + aria-modal="true" + role="dialog".
  - Skip Links: .skip-link elements shown conditionally based on target existence.
  - Form validation: Client-side with server confirmation; clear error messages.
  - State management: data-* attributes for component state; localStorage for persistence.

accessibility:
  - WCAG AA compliance: 4.5:1 contrast ratio, 3:1 for large text.
  - Keyboard navigation: Tab order logical; Enter/Space activate controls.
  - Screen readers: ARIA labels, live regions, semantic HTML structure.
  - Focus management: Visible focus indicators, focus traps for modals.
  - Motion sensitivity: prefers-reduced-motion media query support.
  - Color independence: No color-only information conveyance.
  - Error identification: Clear labels, descriptions, and suggestions.

performance:
  - Core Web Vitals: LCP < 2.5s, CLS < 0.1, FID < 100ms targets.
  - Resource loading: Preconnect to external domains; preload critical fonts.
  - Script optimization: Defer non-critical JS; async third-party scripts.
  - Image optimization: Lazy loading, WebP format, proper dimensions.
  - Bundle size: < 100KB total JS/CSS; tree-shake unused code.
  - Critical path: Inline hero CSS; defer non-visible styles.
  - Caching strategy: Cache headers for static assets; version files.

testing:
  - Unit tests: assets/__tests__/test-runner.html for JS component testing.
  - Integration tests: Manual testing of Quick View, Wishlist, cart flows.
  - Cross-browser: Chrome, Safari, Firefox, Edge compatibility.
  - Accessibility: Keyboard navigation, screen reader testing, contrast ratios.
  - Performance: Lighthouse audits (85+ performance, 90+ accessibility).
  - Responsive: Mobile, tablet, desktop viewport testing.
  - Error handling: Network failures, JavaScript disabled, degraded experiences.

review:
  - Pre-commit checks: Shopify CLI theme check; lint JSON/CSS/JS.
  - Manual testing: Quick View and Wishlist functionality verification.
  - Accessibility audit: Keyboard navigation, screen reader compatibility.
  - Performance validation: Lighthouse scores meet targets.
  - Code review: Follow PR template; test all modified functionality.
  - Documentation: Update README for new features or changes.

contribution:
  - Branch naming: feat/, fix/, refactor/, perf/, docs/, test/ prefixes.
  - Commit messages: Conventional commits with scope (sections/product-card).
  - PR requirements: Description, testing notes, screenshots for UI changes.
  - Code ownership: Review required for layout/, config/, core functionality.
  - Breaking changes: Document in PR description and commit footer.

commits:
  - Format: type(scope): description
  - Types: feat, fix, refactor, perf, docs, test, chore
  - Scope: theme area (sections/product, snippets/card, assets/quick-view)
  - Breaking changes: Add "BREAKING CHANGE:" footer with migration notes
  - Examples: "feat(sections/product): add variant swatches", "fix(snippets/card): resolve lazy loading CLS"

version_control:
  - Rules versioning: Update version number in header for major changes.
  - Change documentation: Document rule modifications in commit messages.
  - Backwards compatibility: Avoid breaking changes; use deprecation warnings.
  - Migration guide: Update README when rules change significantly.